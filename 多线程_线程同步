从java 1.5开始，提供了一些非常有用的辅助类来帮助进行并发编程，
比如CountDownLatch，CyclicBarrier和Semaphore  http://www.cnblogs.com/dolphin0520/p/3920397.html

CountDownLatch

CyclicBarrier(回环栅栏），可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，
CyclicBarrier可以被重用。暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。
使用场景：
    假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，
    此时就可以利用CyclicBarrier了：

Semaphore(信号量）
Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。
若一个工厂有5台机器，8个工人，一台机器同时只能被一个工人使用，使用完了其他工人才能继续使用。那么就可以通过Semaphore来实现


对三个辅助类的总结：
　　1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：
　　　　CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；

　　　　而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；
　　　　    另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。

　　2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。

::关于volatile关键字的用法  http://www.ibm.com/developerworks/cn/java/j-jtp06197.html
    Volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。线程能够自动发现 volatile 变量的最新值。
    Volatile变量可用于提供线程安全，但是只能应用于非常有限的一组用例。 因此，单独使用 volatile 还不足以实现计数器、
    互斥锁或任何具有与多个变量相关的不变式（Invariants）的类
    （例如 “start <=end”）。
    
    正确使用 volatile 变量：
        要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：
            1. 对变量的写操作不依赖于当前值。
            2. 该变量没有包含在具有其他变量的不变式中。
        第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是
        一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确
        的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。（如果将值调整为只从单个线程写入，那么可以
        忽略第一个条件。）
        大多数编程情形都会与这两个条件的其中之一冲突，使得 volatile 变量不能像 synchronized 那样普遍适用于实现线程安全
        
    

